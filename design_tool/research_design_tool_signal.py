bl_info = {
    "name": "Research Design Tool (OBJ Visualizer + Run Pipeline)",
    "author": "You",
    "version": (0, 3, 0),
    "blender": (3, 0, 0),
    "location": "3D Viewport > N-panel > EmbroForm",
    "description": "Run stages, import OBJs, and highlight patch_0..6 by external 0-6 signal.",
    "category": "3D View",
}

import bpy
import os
import sys
import serial
import time
import re


MAX_SIGNAL = 10
_SERIAL_PORT = None
CHANNEL_TO_PATCH = [7, 4, 2, 9, 0, 1]
CHANNEL_THRESH  = [59, 71, 83, 80, 72, 55]
HIGHLIGHT_COLOR = (1.0, 0.0, 0.0, 1.0)   
HIGHLIGHT_EMISSION = (1., 0.25, 0.25, 1.0)
HIGHLIGHT_EMISSION_STRENGTH = 0.0 




class RDT_OT_set_view_standard(bpy.types.Operator):
    bl_idname = "rdt.set_view_standard"
    bl_label = "Use Standard View (sRGB)"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        scn = bpy.context.scene
        scn.display_settings.display_device = 'sRGB'
        scn.view_settings.view_transform = 'Standard'
        scn.view_settings.look = 'None'
        scn.view_settings.exposure = 0.0
        scn.view_settings.gamma = 1.0
        self.report({'INFO'}, "Color Management set to Standard (sRGB)")
        return {'FINISHED'}

class RDT_OT_set_view_filmic(bpy.types.Operator):
    bl_idname = "rdt.set_view_filmic"
    bl_label = "Use Filmic View"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        scn = bpy.context.scene
        scn.display_settings.display_device = 'sRGB'
        scn.view_settings.view_transform = 'Filmic'
        scn.view_settings.look = 'None'
        scn.view_settings.exposure = 0.0
        scn.view_settings.gamma = 1.0
        self.report({'INFO'}, "Color Management set to Filmic")
        return {'FINISHED'}



def _ensure_pyserial():
    try:
        import serial
        return True
    except Exception:
        import subprocess
        try:
            import ensurepip
            ensurepip.bootstrap()
        except Exception:
            pass
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "pyserial"])
            import serial 
            return True
        except Exception as e:
            print(f"[RDT] Failed to install pyserial via pip on {sys.executable}: {e}")
            return False


def get_serial():
    global _SERIAL_PORT
    if _SERIAL_PORT is None:
        if not _ensure_pyserial():
            return None
        import serial, time
        try:
            _SERIAL_PORT = serial.Serial('COM3', 115200, timeout=0.18)
            print("[RDT] Serial opened: COM3 @115200")
        except Exception as e:
            print(f"[RDT] Open serial failed: {e}")
            _SERIAL_PORT = None
    return _SERIAL_PORT




def parse_signal_indices(s: str) -> set:
    if not s:
        return set()

    nums = re.findall(r"-?\d+", s)
    if not nums:
        return set()

    if len(nums) < 6:
        return set()

    try:
        scores = [int(t) for t in nums[:6]]
    except Exception:
        return set()

    active = set()
    for i, score in enumerate(scores):
        if score < CHANNEL_THRESH[i]:
            patch_idx = CHANNEL_TO_PATCH[i]
            if 0 <= patch_idx <= MAX_SIGNAL:
                active.add(patch_idx)

    return active



def user_pipeline(entry_arg: str = "", out_dir: str = "", action: str = "packing") -> str:
    import shutil
    if not out_dir:
        raise ValueError("No output folder set (Preferences > Results Folder).")

    os.makedirs(out_dir, exist_ok=True)
    stage_dir = os.path.join(out_dir, "packing" if action == "packing" else "routing")
    os.makedirs(stage_dir, exist_ok=True)

    if action == "packing":

        candidates = []
        if entry_arg and os.path.isfile(entry_arg):
            candidates.append(entry_arg)
        candidates.append(os.path.join(out_dir, "layout_Birr.obj"))

        src = next((p for p in candidates if os.path.isfile(p)), None)
        if not src:
            raise FileNotFoundError(
                "layout_Birr.obj not found. Put it under Results Folder, "
                "or type its absolute path in the 'Pipeline Arg' field."
            )

        dst = os.path.join(stage_dir, "packing_layout_Birr.obj")
        shutil.copyfile(src, dst)
        return f"packing copied {src} -> {dst}. Arg: {entry_arg}"

    def write_obj(path, verts, faces):
        with open(path, "w", encoding="utf-8") as f:
            f.write("# demo OBJ generated by EmbroForm\n")
            for v in verts:
                f.write(f"v {v[0]} {v[1]} {v[2]}\n")
            for face in faces:
                f.write("f " + " ".join(str(i) for i in face) + "\n")

    v3 = [(-0.5, -1.5, -0.5), (2.0, -1.5, -0.5), (2.0, -1.5, 0.5), (-0.5, -1.5, 0.5)]
    f3 = [(1, 2, 3, 4)]
    write_obj(os.path.join(stage_dir, "routing_ground.obj"), v3, f3)
    v4 = [(0,0,0),(1.5,0,0),(1.5,0,0.01),(0,0,0.01)]
    f4 = [(1,2,3,4)]
    write_obj(os.path.join(stage_dir, "routing_path.obj"), v4, f4)

    return f"{action} wrote OBJ files to {stage_dir}. Arg: {entry_arg}"

# def user_pipeline(entry_arg: str = "", out_dir: str = "", action: str = "packing") -> str:
#     if not out_dir:
#         raise ValueError("No output folder set (Preferences > Results Folder).")

#     os.makedirs(out_dir, exist_ok=True)
#     stage_dir = os.path.join(out_dir, "packing" if action == "packing" else "routing")
#     os.makedirs(stage_dir, exist_ok=True)

#     def write_obj(path, verts, faces):
#         with open(path, "w", encoding="utf-8") as f:
#             f.write("# demo OBJ generated by EmbroForm\n")
#             for v in verts:
#                 f.write(f"v {v[0]} {v[1]} {v[2]}\n")
#             for face in faces:
#                 f.write("f " + " ".join(str(i) for i in face) + "\n")

#     def cube(center, size):
#         cx, cy, cz = center; s = size / 2
#         verts = [
#             (cx - s, cy - s, cz - s), (cx + s, cy - s, cz - s),
#             (cx + s, cy + s, cz - s), (cx - s, cy + s, cz - s),
#             (cx - s, cy - s, cz + s), (cx + s, cy - s, cz + s),
#             (cx + s, cy + s, cz + s), (cx - s, cy + s, cz + s),
#         ]
#         faces = [(1,2,3,4),(5,6,7,8),(1,5,8,4),(2,6,7,3),(1,2,6,5),(4,3,7,8)]
#         return verts, faces

#     if action == "packing":
#         v1, f1 = cube((0.0, 0.0, 0.0), 1.0)
#         v2, f2 = cube((1.5, 0.0, 0.0), 1.0)
#         # write_obj(os.path.join(stage_dir, "packing_patch_00.obj"), v1, f1)
#         # write_obj(os.path.join(stage_dir, "packing_patch_01.obj"), v2, f2)
#         write_obj(os.path.join(stage_dir, "layout_Birr.obj"), v1, f1)
        
#     else:
#         v3 = [(-0.5, -1.5, -0.5), (2.0, -1.5, -0.5), (2.0, -1.5, 0.5), (-0.5, -1.5, 0.5)]
#         f3 = [(1, 2, 3, 4)]
#         write_obj(os.path.join(stage_dir, "routing_ground.obj"), v3, f3)
#         v4 = [(0,0,0),(1.5,0,0),(1.5,0,0.01),(0,0,0.01)]
#         f4 = [(1,2,3,4)]
#         write_obj(os.path.join(stage_dir, "routing_path.obj"), v4, f4)

#     return f"{action} wrote OBJ files to {stage_dir}. Arg: {entry_arg}"


class RDT_Preferences(bpy.types.AddonPreferences):
    bl_idname = __name__

    project_dir: bpy.props.StringProperty(
        name="Project Folder", subtype='DIR_PATH',
        description="Folder that contains your Python modules and data", default=""
    )
    output_dir: bpy.props.StringProperty(
        name="Results Folder", subtype='DIR_PATH',
        description="Where your pipeline writes OBJ files to import", default=""
    )
    add_to_sys_path: bpy.props.BoolProperty(
        name="Add project folder to sys.path", default=True,
        description="Append project folder to sys.path so you can import your modules",
    )

    def draw(self, context):
        layout = self.layout
        col = layout.column()
        col.prop(self, "project_dir")
        col.prop(self, "output_dir")
        col.prop(self, "add_to_sys_path")

def get_prefs() -> RDT_Preferences:
    return bpy.context.preferences.addons[__name__].preferences  # type: ignore

def _maybe_add_sys_path():
    try:
        prefs = get_prefs()
        if prefs.add_to_sys_path and prefs.project_dir and os.path.isdir(prefs.project_dir):
            if prefs.project_dir not in sys.path:
                sys.path.append(prefs.project_dir)
    except Exception:
        pass


class RDT_SceneProps(bpy.types.PropertyGroup):
    import_dir: bpy.props.StringProperty(
        name="Import Folder", subtype='DIR_PATH',
        description="Folder with OBJ files to import", default=""
    )
    clear_collection: bpy.props.BoolProperty(
        name="Clear target collection before import", default=True,
    )
    collection_name: bpy.props.StringProperty(
        name="Target Collection", default="RDT_Results",
        description="Imported meshes will be placed here",
    )
    color_by_patch: bpy.props.BoolProperty(
        name="Auto color by file index", default=True,
    )
    run_arg: bpy.props.StringProperty(
        name="Pipeline Arg", description="Optional argument", default="",
    )
    packing_done: bpy.props.BoolProperty(
        name="Packing Done", default=False,
        description="Stage 1 finished; enable Stage 2 run button"
    )

    sensing_enabled: bpy.props.BoolProperty(
        name="Sensing Enabled", default=False,
        description="Whether Start Sensing is active"
    )
    sensing_interval: bpy.props.FloatProperty(
        name="Interval (sec)", default=0.18, min=0.1, max=10.0
    )
    highlight_collection: bpy.props.StringProperty(
        name="Highlight Collection", default="RDT_Highlight",
        description="Collection that holds imported patch_*.obj for highlighting"
    )


def make_collection(name: str) -> bpy.types.Collection:
    if name in bpy.data.collections:
        return bpy.data.collections[name]
    col = bpy.data.collections.new(name)
    bpy.context.scene.collection.children.link(col)
    return col

def clear_collection(col: bpy.types.Collection):
    for obj in list(col.objects):
        bpy.data.objects.remove(obj, do_unlink=True)

def get_or_create_material(name: str) -> bpy.types.Material:
    mat = bpy.data.materials.get(name)
    if mat is None:
        mat = bpy.data.materials.new(name)
        mat.use_nodes = True
    return mat

def material_for_index(idx: int) -> bpy.types.Material:
    import colorsys
    h = (idx * 0.1618033) % 1.0
    s, v = 0.7, 0.9
    r, g, b = colorsys.hsv_to_rgb(h, s, v)
    mat = get_or_create_material(f"RDT_Mat_{idx:03d}")
    bsdf = mat.node_tree.nodes.get("Principled BSDF")
    if bsdf:
        bsdf.inputs[0].default_value = (r, g, b, 1)
    return mat

def get_or_create_highlight_mat() -> bpy.types.Material:
    mat = bpy.data.materials.get("RDT_Highlight")
    if mat is None:
        mat = bpy.data.materials.new("RDT_Highlight")
        mat.use_nodes = True

    nt = mat.node_tree
    bsdf = nt.nodes.get("Principled BSDF") or nt.nodes.get("Principled BSDF 2.0")
    if bsdf:
        if bsdf.inputs.get("Base Color"):
            bsdf.inputs["Base Color"].default_value = HIGHLIGHT_COLOR
        if HIGHLIGHT_EMISSION_STRENGTH > 0:
            if bsdf.inputs.get("Emission"):
                bsdf.inputs["Emission"].default_value = HIGHLIGHT_EMISSION
            if bsdf.inputs.get("Emission Strength"):
                bsdf.inputs["Emission Strength"].default_value = HIGHLIGHT_EMISSION_STRENGTH
    return mat


def _store_original_materials(obj: bpy.types.Object):
    if obj.type == 'MESH':
        obj["rdt_prev_mats"] = [m.name for m in obj.data.materials] if obj.data.materials else []

def _restore_original_materials(obj: bpy.types.Object):
    if obj.type != 'MESH': return
    prev = obj.get("rdt_prev_mats", None)
    if prev is None: return
    obj.data.materials.clear()
    for name in prev:
        m = bpy.data.materials.get(name)
        if m is not None:
            obj.data.materials.append(m)
    del obj["rdt_prev_mats"]

def highlight_object(obj: bpy.types.Object):
    if obj.type != 'MESH':
        return
    if "rdt_prev_mats" not in obj:
        obj["rdt_prev_mats"] = [m.name for m in obj.data.materials] if obj.data.materials else []
    if "rdt_prev_color" not in obj:
        try:
            obj["rdt_prev_color"] = tuple(obj.color)
        except Exception:
            obj["rdt_prev_color"] = (0.8, 0.8, 0.8, 1.0)

    mat = get_or_create_highlight_mat()
    try:
        obj.color = HIGHLIGHT_COLOR  
    except Exception:
        pass

    obj.data.materials.clear()
    obj.data.materials.append(mat)
    obj["rdt_is_highlighted"] = True


def unhighlight_object(obj: bpy.types.Object):
    if obj.type != 'MESH':
        return
    prev = obj.get("rdt_prev_mats", None)
    obj.data.materials.clear()
    if prev:
        for name in prev:
            m = bpy.data.materials.get(name)
            if m is not None:
                obj.data.materials.append(m)
    prev_c = obj.get("rdt_prev_color", None)
    if prev_c:
        try:
            obj.color = tuple(prev_c)
        except Exception:
            pass
    for k in ("rdt_prev_mats", "rdt_prev_color", "rdt_is_highlighted"):
        if k in obj:
            del obj[k]

def highlight_signal_set(target_indices: set, collection_name: str):

    col = bpy.data.collections.get(collection_name)
    if not col:
        print(f"Collection '{collection_name}' not found")
        return 0, 0

    for attr in ("hide_viewport", "hide_render"):
        if hasattr(col, attr):
            try:
                setattr(col, attr, False)
            except Exception:
                pass

    hi_cnt = 0
    restored = 0

    for obj in col.objects:
        if obj.type != 'MESH':
            continue
        obj_idx = obj.get("rdt_patch_idx", None)

        should_highlight = (obj_idx in target_indices)

        if should_highlight:
            if not obj.get("rdt_is_highlighted"):
                highlight_object(obj)
                hi_cnt += 1
        else:
            if obj.get("rdt_is_highlighted"):
                unhighlight_object(obj)
                restored += 1

    print(f"Highlighted: {hi_cnt}, Restored: {restored}")
    return hi_cnt, restored


def highlight_signal_idx(target_idx: int, collection_name: str):
    return highlight_signal_set({int(target_idx)}, collection_name)

def import_objs_to_collection(directory: str, collection_name: str, colorize: bool = True):
    if not directory or not os.path.isdir(directory):
        return 0
    col = make_collection(collection_name)
    imported = 0
    for i, fname in enumerate(sorted(os.listdir(directory))):
        if not fname.lower().endswith(".obj"):
            continue
        path = os.path.join(directory, fname)
        prev_objs = set(bpy.data.objects)
        if hasattr(bpy.ops.wm, 'obj_import'):
            bpy.ops.wm.obj_import(filepath=path)
        else:
            bpy.ops.import_scene.obj(filepath=path)
        new_objs = [o for o in bpy.data.objects if o not in prev_objs]
        for obj in new_objs:
            base = os.path.splitext(os.path.basename(path))[0]
            obj.name = base
            if obj.name not in col.objects:
                col.objects.link(obj)
            try:
                bpy.context.scene.collection.objects.unlink(obj)
            except Exception:
                pass
            if colorize and getattr(obj.data, "materials", None):
                obj.data.materials.clear()
                obj.data.materials.append(material_for_index(i))
            imported += 1
    return imported

class RDT_OT_import_objs(bpy.types.Operator):
    bl_idname = "rdt.import_objs"
    bl_label = "Import OBJ Folder"
    bl_description = "Import OBJ files from the chosen folder"
    bl_options = {'REGISTER', 'UNDO'}

    kind: bpy.props.StringProperty(default="") 


    def execute(self, context):
        scn = context.scene.rdt
        prefs = get_prefs()
        
        if self.kind == "packing":
            directory = os.path.join(prefs.output_dir or "", "packing")
        elif self.kind == "routing":
            directory = os.path.join(prefs.output_dir or "", "routing")
        else:
            directory = scn.import_dir or get_prefs().output_dir
        
        if not directory or not os.path.isdir(directory):
            self.report({'ERROR'}, f"{self.kind.capitalize()} folder not found: {directory}")
            return {'CANCELLED'}

        col = make_collection(scn.collection_name)
        if scn.clear_collection:
            clear_collection(col)

        imported = 0
        for i, fname in enumerate(sorted(os.listdir(directory))):
            if not fname.lower().endswith(".obj"):
                continue
                
            path = os.path.join(directory, fname)
            prev_objs = set(bpy.data.objects)
            
            try:
                if hasattr(bpy.ops.wm, 'obj_import'):
                    bpy.ops.wm.obj_import(filepath=path)
                else:
                    bpy.ops.import_scene.obj(filepath=path)
            except Exception as e:
                print(f"Failed to import {path}: {e}")
                continue
                
            new_objs = [o for o in bpy.data.objects if o not in prev_objs]
            for obj in new_objs:
                base = os.path.splitext(os.path.basename(path))[0]
                obj.name = base
                
                if obj.name not in col.objects:
                    col.objects.link(obj)
                
                try:
                    bpy.context.scene.collection.objects.unlink(obj)
                except Exception:
                    pass
                
                if scn.color_by_patch and getattr(obj.data, "materials", None):
                    obj.data.materials.clear()
                    obj.data.materials.append(material_for_index(i))
                
                imported += 1

        self.report({'INFO'}, f"Imported {imported} OBJ(s) from {self.kind}")
        return {'FINISHED'}

class RDT_OT_run_stage(bpy.types.Operator):
    bl_idname = "rdt.run_stage"
    bl_label = "Run Stage"
    bl_options = {'REGISTER', 'UNDO'}

    action: bpy.props.EnumProperty(
        name="Action",
        items=(("packing", "2D Packing", "Run 2D packing and write OBJs"),
               ("routing", "Design Routing Path", "Run routing and write OBJs")),
        default="packing"
    )

    def execute(self, context):
        scn = context.scene.rdt
        prefs = get_prefs()
        out_dir = prefs.output_dir
        if not out_dir:
            self.report({'ERROR'}, "Results Folder is empty (Preferences).")
            return {'CANCELLED'}

        try:
            msg = user_pipeline(entry_arg=scn.run_arg, out_dir=out_dir, action=self.action)
        except Exception as e:
            self.report({'ERROR'}, f"Stage '{self.action}' failed: {e}")
            return {'CANCELLED'}

        if self.action == "packing":
            scn.packing_done = True

        self.report({'INFO'}, msg)
        return {'FINISHED'}


_SENSING_REGISTERED = False

import re
def _ensure_highlight_loaded(scn, prefs) -> int:
    highlight_dir = os.path.join(prefs.output_dir or "", "highlight")
    if not os.path.isdir(highlight_dir):
        print(f"Highlight directory not found: {highlight_dir}")
        return 0
    
    col = make_collection(scn.highlight_collection)

    names = {o.name for o in col.objects}
    needed = {f"patch_{i}" for i in range(MAX_SIGNAL+1)}
    
    if needed.issubset(names):
        for obj in col.objects:
            if "rdt_patch_idx" not in obj:
                match = re.search(r'patch[_\-]?(\d+)', obj.name.lower())
                if match:
                    try:
                        obj["rdt_patch_idx"] = int(match.group(1))
                        print(f"Set rdt_patch_idx={obj['rdt_patch_idx']} for {obj.name}")
                    except ValueError:
                        pass
        return 0

    count = 0
    for i in range(MAX_SIGNAL+1):
        obj_name = f"patch_{i}"
        obj_path = os.path.join(highlight_dir, f"{obj_name}.obj")
        
        if not os.path.exists(obj_path):
            print(f"Missing patch file: {obj_path}")
            continue
            
        prev_objs = set(bpy.data.objects)
        try:
            if hasattr(bpy.ops.wm, 'obj_import'):
                bpy.ops.wm.obj_import(filepath=obj_path)
            else:
                bpy.ops.import_scene.obj(filepath=obj_path)
        except Exception as e:
            print(f"Failed to import {obj_path}: {e}")
            continue
            
        new_objs = [o for o in bpy.data.objects if o not in prev_objs]
        for obj in new_objs:
            obj.name = obj_name 
            obj["rdt_patch_idx"] = i 
            
            if obj.name not in col.objects:
                col.objects.link(obj)
            
            try:
                if obj.name in bpy.context.scene.collection.objects:
                    bpy.context.scene.collection.objects.unlink(obj)
            except Exception:
                pass
                
            count += 1
            print(f"Imported and tagged {obj.name} with index {i}")

    return count


def _sensing_tick():
    global _SENSING_REGISTERED
    scene = bpy.context.scene
    scn = getattr(scene, "rdt", None)
    if scn is None:
        _SENSING_REGISTERED = False
        return None
    if not scn.sensing_enabled:
        _SENSING_REGISTERED = False
        return None

    try:
        prefs = get_prefs()
        _ensure_highlight_loaded(scn, prefs)

        # sig_path = os.path.join(prefs.output_dir or "", "highlight", "signal.txt")
        # if os.path.isfile(sig_path):
        #     content = open(sig_path, "r", encoding="utf-8").read().strip()
        #     try:
        #         val = int(content)
        #     except Exception:
        #         val = 0
        #     if val < 0 or val > MAX_SIGNAL:
        #         val = max(0, min(MAX_SIGNAL, val))
        #     highlight_signal_idx(val, scn.highlight_collection)

        ser = get_serial()
        indices = set()
        ser = get_serial()
        indices = set()
        if ser:
            try:
                line = ser.readline().decode("utf-8", errors="ignore").strip()
                print(f"[RDT] Raw serial data: '{line}'")
                if line:
                    indices = parse_signal_indices(line)
                    print(f"[RDT] Parsed indices: {sorted(indices)}")
            except Exception as e:
                print(f"[RDT] Serial read error: {e}")



        if not indices:
            
            highlight_signal_set(set(), scn.highlight_collection)
        else:
            highlight_signal_set(indices, scn.highlight_collection)

        if indices:
            highlight_signal_set(indices, scn.highlight_collection)


    except Exception:
        pass

    return max(0.1, float(scn.sensing_interval))


class RDT_OT_apply_signal_once(bpy.types.Operator):
    bl_idname = "rdt.apply_signal_once"
    bl_label = "Apply Current Signal (once)"
    bl_options = {'REGISTER'}

    def execute(self, context):
        # scn = context.scene.rdt
        # prefs = get_prefs()
        # highlight_dir = os.path.join(prefs.output_dir or "", "highlight")
        # sig_path = os.path.join(highlight_dir, "signal.txt")
        
        # print(f"Looking for signal file: {sig_path}")
        
        # if not os.path.isfile(sig_path):
        #     self.report({'ERROR'}, f"signal.txt not found at {sig_path}")
        #     return {'CANCELLED'}
            
        # try:
        #     content = open(sig_path, "r", encoding="utf-8").read().strip()
        #     print(f"Signal file content: '{content}'")
        #     val = int(content)
        # except Exception as e:
        #     self.report({'ERROR'}, f"Invalid signal.txt: {e}")
        #     return {'CANCELLED'}
            
        # val = min(MAX_SIGNAL, max(0, val))
        # print(f"Processing signal value: {val}")
        
        # _ensure_highlight_loaded(scn, prefs)

        # col = bpy.data.collections.get(scn.highlight_collection)
        # if col:
        #     print(f"Collection '{scn.highlight_collection}' contains:")
        #     for obj in col.objects:
        #         idx = obj.get("rdt_patch_idx", "None")
        #         print(f"  - {obj.name}: rdt_patch_idx = {idx}")
        
        # hi, rest = highlight_signal_idx(val, scn.highlight_collection)
        # self.report({'INFO'}, f"Applied signal={val}: highlighted {hi}, restored {rest}")

        ser = get_serial()
        if not ser:
            self.report({'ERROR'}, "No serial port available")
            return {'CANCELLED'}

        try:
            line = ser.readline().decode("utf-8").strip()
            if not line:
                self.report({'ERROR'}, "No data from Arduino")
                return {'CANCELLED'}
            print(f"Arduino says: {line}")
            indices = parse_signal_indices(line)
        except Exception as e:
            self.report({'ERROR'}, f"Serial read failed: {e}")
            return {'CANCELLED'}

        if not indices:
            self.report({'ERROR'}, "Parsed no valid indices")
            return {'CANCELLED'}

        hi, rest = highlight_signal_set(indices, scn.highlight_collection)
        self.report({'INFO'}, f"Applied indices={sorted(indices)}: highlighted {hi}, restored {rest}")
        return {'FINISHED'}




class RDT_OT_start_sensing(bpy.types.Operator):
    bl_idname = "rdt.start_sensing"
    bl_label = "Start Sensing (0-6)"
    bl_options = {'REGISTER'}

    def execute(self, context):
        global _SENSING_REGISTERED
        scn = context.scene.rdt
        prefs = get_prefs()
        if not prefs.output_dir:
            self.report({'ERROR'}, "Results Folder is empty (Preferences).")
            return {'CANCELLED'}

        imported = _ensure_highlight_loaded(scn, prefs)
        col = bpy.data.collections.get(scn.highlight_collection)
        if col:
            try: col.hide_viewport = False
            except Exception: pass
            try: col.hide_render = False
            except Exception: pass

        scn.sensing_enabled = True
        if not _SENSING_REGISTERED:
            bpy.app.timers.register(_sensing_tick, first_interval=0.0, persistent=True)
            _SENSING_REGISTERED = True

        self.report({'INFO'}, f"Sensing started. Imported {imported} patch objs (if any).")
        return {'FINISHED'}

class RDT_OT_stop_sensing(bpy.types.Operator):
    bl_idname = "rdt.stop_sensing"
    bl_label = "Stop Sensing"
    bl_options = {'REGISTER'}

    def execute(self, context):
        global _SENSING_REGISTERED
        scn = context.scene.rdt
        scn.sensing_enabled = False
        _SENSING_REGISTERED = False
        self.report({'INFO'}, "Sensing stopped.")
        return {'FINISHED'}

class RDT_OT_clear_collection(bpy.types.Operator):
    bl_idname = "rdt.clear_collection"
    bl_label = "Clear Collection"
    bl_description = "Delete all objects in the target collection"

    def execute(self, context):
        scn = context.scene.rdt
        col = make_collection(scn.collection_name)
        clear_collection(col)
        self.report({'INFO'}, f"Cleared {scn.collection_name}")
        return {'FINISHED'}


class RDT_PT_panel(bpy.types.Panel):
    bl_label = "EmbroForm Design Tool"
    bl_idname = "RDT_PT_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'EmbroForm'

    def draw(self, context):
        scn = context.scene.rdt
        prefs = get_prefs()
        layout = self.layout

        # box = layout.box()
        # box.label(text="Paths")
        # row = box.row()
        # row.prop(prefs, "project_dir", text="Modules")
        # row = box.row()
        # row.prop(prefs, "output_dir", text="Results")
        # box.prop(prefs, "add_to_sys_path")

        # box = layout.box()
        # box.label(text="2D Packing")
        # box.prop(scn, "run_arg", text="Arg")
        
        # row = box.row()
        # op = row.operator("rdt.run_stage", text="Run 2D Packing", icon='PLAY')
        # op.action = "packing"
        
        # row = box.row()
        # imp1 = row.operator("rdt.import_objs", text="Show Packing Results", icon='IMPORT')
        # imp1.kind = "packing"
        
        # if prefs.output_dir:
        #     packing_path = os.path.join(prefs.output_dir, "packing")
        #     box.label(text=f"From: {packing_path}", icon='FILE_FOLDER')

        # box = layout.box()
        # box.label(text="Design Routing Path")
        
        # if not scn.packing_done:
        #     row = box.row()
        #     row.label(text="(Run 2D Packing first)", icon='INFO')
        
        # row = box.row()
        # op = row.operator("rdt.run_stage", text="Run Routing", icon='PLAY')
        # op.action = "routing"
        
        # row = box.row()
        # imp2 = row.operator("rdt.import_objs", text="Show Routing Results", icon='IMPORT')
        # imp2.kind = "routing"

        # if prefs.output_dir:
        #     routing_path = os.path.join(prefs.output_dir, "routing")
        #     box.label(text=f"From: {routing_path}", icon='FILE_FOLDER')

        box = layout.box()
        box.label(text=f"Signal Highlight (supports list 0..{MAX_SIGNAL})")
        
        row = box.row(align=True)
        row.prop(scn, "highlight_collection", text="Collection")
        
        row = box.row(align=True)
        row.operator("rdt.start_sensing", text="Start", icon='LIGHT')
        row.operator("rdt.stop_sensing", text="Stop", icon='PAUSE')
        
        row = box.row(align=True)
        row.operator("rdt.apply_signal_once", text="Apply Signal", icon='EVENT_S')
        
        row = box.row(align=True)
        row.prop(scn, "sensing_interval", slider=True)
        
        if prefs.output_dir:
            highlight_path = os.path.join(prefs.output_dir, "highlight")
            box.label(text=f"From: {highlight_path}", icon='FILE_FOLDER')

        # box = layout.box()
        # box.label(text="Utilities")
        
        # row = box.row()
        # row.prop(scn, "collection_name", text="Target")
        
        # row = box.row(align=True)
        # row.prop(scn, "clear_collection", text="Clear")
        # row.prop(scn, "color_by_patch", text="Auto Color")

        # row = box.row()
        # row.prop(scn, "import_dir", text="Import")
        
        # row = box.row()
        # row.operator("rdt.clear_collection", text="Clear Collection", icon='TRASH')

# ----------------------------------------------------------------------------- #
# Registration
# ----------------------------------------------------------------------------- #
classes = (
    RDT_Preferences,
    RDT_SceneProps,
    RDT_OT_import_objs,
    RDT_OT_run_stage,
    RDT_OT_start_sensing,
    RDT_OT_stop_sensing,
    RDT_OT_clear_collection,
    RDT_OT_apply_signal_once, 
    RDT_PT_panel,
    RDT_OT_set_view_standard,
    RDT_OT_set_view_filmic,

)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.rdt = bpy.props.PointerProperty(type=RDT_SceneProps)
    _maybe_add_sys_path()

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    if hasattr(bpy.types.Scene, 'rdt'):
        del bpy.types.Scene.rdt

if __name__ == "__main__":
    register()
